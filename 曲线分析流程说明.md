# 曲线分析流程说明

## 一、概述

曲线分析系统用于分析钢琴按键的`after_touch`（触后）曲线，重点关注**上升沿**和**下降沿**的特征。系统使用**基于导数的DTW对齐**方法，能够更准确地比较不同算法对力度曲线的还原度。

---

## 二、核心组件

### 2.1 主要类

1. **`ForceCurveAnalyzer`** - 力度曲线分析器（主类）
   - 功能：提取上升沿/下降沿，对比两条曲线
   - 位置：`backend/force_curve_analyzer.py`

2. **`DerivativeDTWAligner`** - 基于导数的DTW对齐器（核心算法）
   - 功能：对曲线的导数（斜率）进行DTW对齐
   - 位置：`backend/force_curve_analyzer.py`

### 2.2 设计理念

- **为什么使用导数？**
  - 上升沿和下降沿的本质是**变化率**（斜率）
  - 导数更能反映曲线的变化趋势
  - 对小幅抖动更鲁棒（小幅抖动在导数上的影响相对较小）

- **为什么使用DTW？**
  - 处理时间扭曲（不同算法可能在不同时刻有不同速度）
  - 对齐相似的特征点（快速上升段、平台段、快速下降段）

---

## 三、完整流程

### 3.1 流程图（改进版）

```
输入：两条after_touch曲线（note1, note2）
  ↓
步骤1：提取完整曲线数据
  ├─ 提取after_touch数据（时间和值）
  └─ 高斯平滑（减少抖动）
  ↓
步骤2：对齐完整曲线（基于导数的DTW）
  ├─ 计算导数（斜率）
  ├─ 归一化导数（消除绝对幅度差异）
  ├─ DTW对齐导数序列（处理时间扭曲）
  ├─ 根据对齐路径重新采样原始曲线
  └─ 在对齐后的曲线上找到峰值点对应关系
  ↓
步骤3：在对齐后的曲线上提取上升沿和下降沿
  ├─ 使用对齐后的峰值点作为分割点
  ├─ 上升沿：从开始到峰值（对齐后的曲线）
  └─ 下降沿：从峰值到结束（对齐后的曲线）
  ↓
步骤4：计算相似度
  ├─ 上升沿相似度（时间轴已对齐，直接计算）
  ├─ 下降沿相似度（时间轴已对齐，直接计算）
  └─ 整体相似度 = (上升沿相似度 + 下降沿相似度) / 2
  ↓
输出：相似度结果（0-1，1表示完全相同）
```

### 3.1.1 改进说明

**改进前的问题**：
- 先提取边缘，再对齐，可能导致峰值点不对应
- 如果两条曲线的峰值位置差异很大，提取的边缘可能不匹配

**改进后的优势**：
- ✅ 先建立整体对应关系，确保峰值点对应
- ✅ 在对齐后的曲线上提取边缘，更准确
- ✅ 更符合物理意义：先整体，后局部
- ✅ 峰值点更可能对应相同的物理事件

### 3.2 详细步骤（改进版）

#### 步骤1：提取完整曲线数据（`_extract_full_curve`）

**输入**：音符对象（包含`after_touch`数据）

**处理**：
1. 提取时间和值
   ```python
   times = (note.after_touch.index + note.offset) / 10.0  # 转换为ms
   values = note.after_touch.values
   ```

2. 高斯平滑（减少抖动）
   ```python
   values = gaussian_filter1d(values, sigma=smooth_sigma)
   ```

**输出**：
- `(times, values)` - 完整曲线数据（不分割）

---

#### 步骤2：对齐完整曲线（`DerivativeDTWAligner.align_full_curves`）

**输入**：两条完整曲线

**处理流程**：

##### 2.1 平滑处理
```python
# 在计算导数之前先平滑，避免导数放大噪声
values1_smooth = gaussian_filter1d(values1, sigma=smooth_sigma)
values2_smooth = gaussian_filter1d(values2, sigma=smooth_sigma)
```

##### 2.2 计算导数（斜率）
```python
# 使用np.gradient计算数值导数
# 对于内部点：使用中心差分法 (f(x+h) - f(x-h)) / (2h)
# 对于边界点：使用前向/后向差分法
derivatives1 = np.gradient(values1_smooth, times1)
derivatives2 = np.gradient(values2_smooth, times2)
```

**导数的意义**：
- 反映曲线的变化率（斜率）
- 上升沿：导数为正，表示力度在增加
- 下降沿：导数为负，表示力度在减少
- 平台段：导数接近0，表示力度基本不变

##### 2.3 归一化导数
```python
# 归一化到[-1, 1]范围，消除绝对幅度差异，只关注变化趋势
max_abs_derivative = np.max(np.abs(derivatives))
normalized = derivatives / max_abs_derivative
```

**为什么归一化？**
- 消除绝对幅度的差异（不同算法的力度范围可能不同）
- 只关注变化趋势（形状），而非绝对大小

##### 2.4 DTW对齐导数序列
```python
# 对归一化后的导数序列进行DTW对齐
alignment = dtw(derivatives1_norm, derivatives2_norm, ...)
alignment_path = [(i, j), ...]  # 对齐路径
```

**DTW对齐的作用**：
- 找到两条导数序列之间的最优对齐路径
- 对齐路径告诉我们：`derivatives1`的第`i`个点应该与`derivatives2`的第`j`个点对齐
- 处理时间扭曲（即使时间分布不同，只要斜率模式相似就能对齐）

##### 2.5 根据对齐路径重新采样原始曲线
```python
# 使用对齐路径将两条曲线映射到统一的时间轴上
for i, j in alignment_path:
    aligned_time = (times1[i] + times2[j]) / 2.0
    aligned_values1.append(values1[i])
    aligned_values2.append(values2[j])
```

**输出**：
- `aligned_times`: 对齐后的时间点数组（归一化到[0,1]）
- `aligned_values1`, `aligned_values2`: 对齐后的曲线值
- `alignment_path`: DTW对齐路径
- `dtw_distance`: DTW距离（越小表示越相似）
- `peak_indices1`, `peak_indices2`: 对齐后的峰值索引

---

#### 步骤3：在对齐后的曲线上提取上升沿和下降沿

**输入**：对齐后的完整曲线和峰值索引

**处理**：
```python
# 使用两个峰值索引的平均值作为分割点，确保对应关系
split_idx = max(peak_idx1, peak_idx2)

# 上升沿：从开始到分割点（包含分割点）
rising_times = aligned_times[:split_idx + 1]
rising_values1 = aligned_values1[:split_idx + 1]
rising_values2 = aligned_values2[:split_idx + 1]

# 下降沿：从分割点到结束（包含分割点）
falling_times = aligned_times[split_idx:]
falling_values1 = aligned_values1[split_idx:]
falling_values2 = aligned_values2[split_idx:]
```

**优势**：
- ✅ 峰值点已经对应（通过DTW对齐）
- ✅ 边缘提取更准确（基于对齐后的曲线）
- ✅ 确保上升沿和下降沿对应相同的特征点

---

#### 步骤4：计算相似度（`_compute_edge_similarity`）

**输入**：对齐后的两条边缘（时间轴已对齐）

**处理**：

##### 4.1 值归一化
```python
# 归一化到[0, 1]区间，消除绝对力度差异
norm_values1 = (aligned_values1 - aligned_values1.min()) / 
                (aligned_values1.max() - aligned_values1.min())
norm_values2 = (aligned_values2 - aligned_values2.min()) / 
                (aligned_values2.max() - aligned_values2.min())
```

**为什么再次归一化？**
- 虽然导数已经归一化，但原始值可能仍有幅度差异
- 归一化后只关注形状，而非绝对大小

##### 4.2 计算差异
```python
# 计算对齐后的曲线之间的差异
diff = np.abs(norm_values1 - norm_values2)
mean_diff = np.mean(diff)  # 平均差异
max_diff = np.max(diff)    # 最大差异
```

##### 4.3 计算相似度
```python
# 相似度 = 1 - 平均差异（差异越小，相似度越高）
similarity = max(0.0, 1.0 - mean_diff)
```

**输出**：
- `similarity`: 相似度（0-1，1表示完全相同）
- `mean_diff`: 平均差异
- `max_diff`: 最大差异
- `dtw_distance`: DTW距离（参考指标）

---

#### 步骤5：整体对比（`compare_curves`）

**输入**：两条完整的`after_touch`曲线

**处理**：
```python
# 1. 提取完整曲线数据
curve1_data = _extract_full_curve(note1)
curve2_data = _extract_full_curve(note2)

# 2. 对齐完整曲线（基于导数的DTW）
alignment_result = align_full_curves(curve1_data, curve2_data)

# 3. 在对齐后的曲线上提取上升沿和下降沿
# （使用对齐后的峰值点作为分割点）

# 4. 分别计算上升沿和下降沿的相似度
rising_similarity = _compute_edge_similarity(rising_edge1, rising_edge2)
falling_similarity = _compute_edge_similarity(falling_edge1, falling_edge2)

# 5. 计算整体相似度
overall_similarity = (rising_similarity['similarity'] + falling_similarity['similarity']) / 2.0
```

**输出**：
- `rising_edge_similarity`: 上升沿相似度（0-1）
- `falling_edge_similarity`: 下降沿相似度（0-1）
- `overall_similarity`: 整体相似度（0-1）
- `rising_edge_diff`: 上升沿差异统计
- `falling_edge_diff`: 下降沿差异统计

---

## 四、关键参数

### 4.1 平滑参数（`smooth_sigma`）

- **作用**：高斯平滑的标准差，用于减少抖动影响
- **推荐值**：1.0-2.0
- **影响**：
  - 值越大：平滑程度越高，但可能丢失细节
  - 值越小：保留更多细节，但可能受噪声影响
  - 0：不平滑（不推荐，因为导数会放大噪声）

### 4.2 DTW距离度量（`distance_metric`）

- **可选值**：
  - `'manhattan'`: 曼哈顿距离（L1距离，**推荐**，对抖动更鲁棒）
  - `'euclidean'`: 欧式距离（默认，对抖动敏感）
  - `'chebyshev'`: 切比雪夫距离（关注最大差异）

### 4.3 DTW窗口大小（`window_size_ratio`）

- **作用**：限制对齐范围，避免过度扭曲
- **推荐值**：0.5（窗口大小为序列长度的50%）
- **影响**：
  - 值越大：允许更大的时间扭曲，但可能过度扭曲
  - 值越小：限制时间扭曲，但可能无法对齐相似的特征

---

## 五、改进后的优势

### 5.1 先对齐再提取的优势

1. **峰值点更准确**
   - 先对齐完整曲线，确保峰值点对应
   - 即使原始峰值位置不同，对齐后也能找到对应关系
   - 峰值点更可能对应相同的物理事件

2. **边缘提取更准确**
   - 在对齐后的曲线上提取边缘，更可能对应相同的特征点
   - 确保上升沿和下降沿对应相同的物理过程

3. **更符合物理意义**
   - 先建立整体对应关系，再分析局部特征
   - 更符合"先整体，后局部"的分析思路

4. **回退机制**
   - 如果完整曲线对齐失败，自动回退到旧方法
   - 保证系统的鲁棒性

### 5.2 基于导数的优势

1. **符合"沿"的本质**
   - 上升沿和下降沿的本质是变化率（斜率）
   - 导数直接反映这个特征

2. **对抖动更鲁棒**
   - 小幅抖动在原始值上明显，但在导数上影响相对较小
   - 只要变化趋势一致，导数相似度就高

3. **对齐更准确**
   - 能对齐相似的变化模式（快速上升、缓慢下降等）
   - 即使时间分布不同，只要斜率模式相似就能对齐

### 5.2 DTW对齐的优势

1. **处理时间扭曲**
   - 不同算法可能在不同时刻有不同速度
   - DTW能处理这种非线性时间扭曲

2. **对齐特征点**
   - 能对齐相似的特征点（快速上升段、平台段、快速下降段）
   - 即使整体时间分布不同，也能找到对应关系

### 5.3 整体设计优势

1. **面向对象设计**
   - `DerivativeDTWAligner`独立封装，职责清晰
   - `ForceCurveAnalyzer`协调整个流程

2. **详细注释**
   - 每个方法都有详细的文档字符串
   - 关键步骤都有行内注释

3. **鲁棒性**
   - 先平滑再计算导数，避免噪声放大
   - 支持多种距离度量方式和参数配置

---

## 六、使用示例

```python
from backend.force_curve_analyzer import ForceCurveAnalyzer

# 创建分析器
analyzer = ForceCurveAnalyzer(
    smooth_sigma=1.0,              # 高斯平滑参数
    dtw_distance_metric='manhattan',  # DTW距离度量（推荐）
    dtw_window_size_ratio=0.5      # DTW窗口大小比例
)

# 对比两条曲线
result = analyzer.compare_curves(note1, note2)

if result:
    print(f"上升沿相似度: {result['rising_edge_similarity']:.3f}")
    print(f"下降沿相似度: {result['falling_edge_similarity']:.3f}")
    print(f"整体相似度: {result['overall_similarity']:.3f}")
```

---

## 七、应用场景

1. **算法评估**
   - 对比不同算法对力度曲线的还原度
   - 评估算法对上升沿和下降沿的还原质量

2. **匹配算法增强**
   - 在时间匹配的基础上，加入力度曲线相似度
   - 时间匹配但力度曲线差异大时，降低匹配优先级

3. **异常检测**
   - 识别力度曲线形状异常的按键
   - 检测算法还原失败的情况

---

## 八、总结

曲线分析系统采用**基于导数的DTW对齐**方法，能够：

1. ✅ 准确提取上升沿和下降沿
2. ✅ 处理时间扭曲和局部抖动
3. ✅ 公平地比较不同算法的曲线还原度
4. ✅ 提供量化的相似度指标

该方法特别适合分析钢琴按键的力度曲线，能够有效评估算法对"上升沿"和"下降沿"的还原质量。

