# 同种算法不同曲子的相对延时分布图 - 代码与流程说明

## 一、概述

本功能用于可视化同种算法在不同曲子上的相对延时分布情况，通过直方图和密度曲线展示延时数据的分布特征，帮助分析算法在不同曲子上的表现一致性。

**核心文件位置**：
- 数据分析：`backend/piano_analysis_backend.py:get_same_algorithm_relative_delay_analysis()`
- 图表生成：`backend/multi_algorithm_plot_generator.py:generate_relative_delay_distribution_plot()`

---

## 二、完整流程

```
1. 算法识别：按display_name分组，识别同种算法的不同曲子
   ↓
2. 数据提取：从每个曲子的offset_data中提取keyon_offset
   ↓
3. 相对延时计算：每个点的延时减去该算法的平均延时
   ↓
4. 数据分组：单个曲子数据 + 算法组汇总数据
   ↓
5. 子图创建：为每个曲子和汇总创建独立的子图
   ↓
6. 分布可视化：直方图 + KDE密度曲线
   ↓
7. 统计标注：均值线、中位数线、σ区间背景
   ↓
8. 布局优化：动态高度调整，统一格式
```

---

## 三、详细代码实现

### 3.1 数据分析阶段

**文件**：`backend/piano_analysis_backend.py`

```python
def get_same_algorithm_relative_delay_analysis(self) -> Dict[str, Any]:
    """
    分析同种算法不同曲子的相对延时分布

    识别逻辑：
    - display_name 相同：表示同种算法
    - algorithm_name 不同：表示不同曲子（因为文件名不同）
    """
```

#### 3.1.1 算法识别逻辑

```python
# 按display_name分组，识别同种算法
algorithm_groups = defaultdict(list)

for algorithm in all_algorithms:
    if not algorithm.is_ready():
        continue

    display_name = algorithm.metadata.display_name
    algorithm_groups[display_name].append(algorithm)

# 找出有多个曲子的算法（同种算法的不同曲子）
same_algorithm_groups = {}
for display_name, algorithms in algorithm_groups.items():
    if len(algorithms) > 1:
        # 检查是否真的是不同曲子（algorithm_name不同）
        algorithm_names = set(alg.metadata.algorithm_name for alg in algorithms)
        if len(algorithm_names) > 1:
            same_algorithm_groups[display_name] = algorithms
```

#### 3.1.2 相对延时计算

```python
# 分析每个算法的相对延时分布
all_relative_delays = []  # 合并所有曲子的相对延时

for display_name, algorithms in same_algorithm_groups.items():
    group_relative_delays = []  # 该算法组所有曲子合并后的相对延时

    for algorithm in algorithms:
        # 计算该算法的平均延时（用于计算相对延时）
        keyon_offsets_ms = [
            data['keyon_offset'] * 1000 / algorithm.metadata.sample_rate
            for data in algorithm.offset_data
        ]

        if not keyon_offsets_ms:
            continue

        # 计算相对延时：延时 - 平均延时
        mean_delay = sum(keyon_offsets_ms) / len(keyon_offsets_ms)
        relative_delays = [
            offset - mean_delay
            for offset in keyon_offsets_ms
        ]

        # 保存单个曲子的数据
        song_data.append({
            'filename': algorithm.metadata.algorithm_name,
            'filename_display': filename_display,
            'relative_delays': relative_delays,  # 该曲子的相对延时列表
        })

        group_relative_delays.extend(relative_delays)  # 合并到算法组

    # 保存算法组的汇总数据
    same_algorithm_groups[display_name] = {
        'song_data': song_data,  # 每个曲子的数据
        'relative_delays': group_relative_delays,  # 合并后的相对延时
    }
```

### 3.2 图表生成阶段

**文件**：`backend/multi_algorithm_plot_generator.py`

```python
def generate_relative_delay_distribution_plot(self, analysis_result: Dict[str, Any]) -> Any:
    """
    生成相对延时分布直方图 + 密度曲线

    每个曲子单独一个子图，最后是汇总图
    """
```

#### 3.2.1 数据准备

```python
# 收集所有需要绘制的曲子信息
all_songs = []  # [(display_name, filename_display, relative_delays, group_relative_delays), ...]

for display_name, group_data in algorithm_groups.items():
    song_data = group_data.get('song_data', [])
    group_relative_delays = group_data.get('relative_delays', [])

    if not group_relative_delays:
        continue

    # 添加每个曲子
    for song_info in song_data:
        song_relative_delays = song_info.get('relative_delays', [])
        if song_relative_delays:
            filename_display = song_info.get('filename_display', song_info.get('filename', '未知文件'))
            all_songs.append((display_name, filename_display, song_relative_delays, None))

    # 添加汇总（每个算法组一个汇总）
    all_songs.append((display_name, '汇总', None, group_relative_delays))
```

#### 3.2.2 子图创建

```python
# 创建子图：每个曲子一个子图 + 每个算法组一个汇总子图
num_subplots = len(all_songs)
subplot_titles = []
for display_name, filename_display, _, _ in all_songs:
    if filename_display == '汇总':
        subplot_titles.append(f'{display_name} (汇总)')
    else:
        subplot_titles.append(f'{display_name} - {filename_display}')

# 创建子图
fig = make_subplots(
    rows=num_subplots,
    cols=1,
    subplot_titles=subplot_titles,
    vertical_spacing=0.06,  # 减小子图之间的间距
    row_heights=[1.0] * num_subplots  # 每个子图高度相等
)
```

#### 3.2.3 分布可视化

```python
# 颜色方案
colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f']

# 为每个子图绘制数据
algorithm_color_map = {}  # 记录每个算法使用的颜色

for subplot_idx, (display_name, filename_display, song_relative_delays, group_relative_delays) in enumerate(all_songs, 1):
    # 确定使用的数据
    if filename_display == '汇总':
        delays_array = np.array(group_relative_delays)  # 汇总图：使用合并后的数据
    else:
        delays_array = np.array(song_relative_delays)   # 单个曲子：使用该曲子的数据

    # 计算直方图数据
    hist, bin_edges = np.histogram(delays_array, bins=50, density=False)
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2

    # 计算密度曲线（KDE）
    kde = stats.gaussian_kde(delays_array)
    x_density = np.linspace(delays_array.min(), delays_array.max(), 200)
    y_density = kde(x_density) * len(delays_array)  # 转换为频数

    # 添加直方图
    fig.add_trace(
        go.Bar(
            x=bin_centers,
            y=hist,
            name='相对延时分布',
            marker=dict(color=f'rgba({r}, {g}, {b}, 0.6)', line=dict(color=base_color, width=1.5 if filename_display == '汇总' else 1)),
            opacity=0.7,
            showlegend=False,  # 不在图注中显示，因为每个子图独立
            hovertemplate=f'相对延时: %{x:.2f} ms<br>频数: %{y}<extra></extra>',
            customdata=customdata_list  # 添加customdata用于点击回调
        ),
        row=subplot_idx, col=1
    )

    # 添加密度曲线
    fig.add_trace(
        go.Scatter(
            x=x_density,
            y=y_density,
            mode='lines',
            name='密度曲线',
            line=dict(color=base_color, width=3 if filename_display == '汇总' else 2, dash='dash' if filename_display == '汇总' else 'solid'),
            showlegend=False,  # 不在图注中显示
            hovertemplate=f'相对延时: %{x:.2f} ms<br>密度: %{y:.2f}<extra></extra>'
        ),
        row=subplot_idx, col=1
    )
```

#### 3.2.4 统计信息标注

```python
# 为每个子图添加统计量标注和布局设置
for subplot_idx, (display_name, filename_display, song_relative_delays, group_relative_delays) in enumerate(all_songs, 1):
    # 计算统计量
    mean = np.mean(delays_array)
    std = np.std(delays_array)
    median = np.median(delays_array)

    # 计算±1σ、±2σ、±3σ的百分比
    within_1sigma = np.sum(np.abs(delays_array - mean) <= std) / count * 100
    within_2sigma = np.sum(np.abs(delays_array - mean) <= 2 * std) / count * 100
    within_3sigma = np.sum(np.abs(delays_array - mean) <= 3 * std) / count * 100

    # 添加±1σ、±2σ、±3σ区间（背景色区域）
    for sigma, color in [(1, 'rgba(255, 0, 0, 0.08)'),   # ±1σ：浅红色
                         (2, 'rgba(255, 0, 0, 0.12)'),   # ±2σ：稍深红色
                         (3, 'rgba(255, 0, 0, 0.15)')]:  # ±3σ：更深红色
        fig.add_vrect(
            x0=mean - sigma * std,
            x1=mean + sigma * std,
            fillcolor=color,
            layer="below",
            line_width=0,
            row=subplot_idx, col=1
        )

    # 获取子图的Y轴范围，用于绘制参考线
    y_min, y_max = delays_array.min(), delays_array.max()
    y_range = y_max - y_min
    y_line_max = y_max + y_range * 0.1  # 稍微超出数据范围

    # 添加均值线（使用Scatter实现带悬停信息的垂直线）
    fig.add_trace(
        go.Scatter(
            x=[mean, mean],
            y=[0, y_line_max],
            mode='lines',
            name=f'均值: {mean:.2f}ms',
            line=dict(
                color='#2E8B57',  # 深绿色，更明显
                width=2.5,       # 增加线宽
                dash='dash'
            ),
            showlegend=False,
            hovertemplate=f'均值: {mean:.2f} ms<extra></extra>',
            hoverlabel=dict(bgcolor='rgba(46, 139, 87, 0.8)')
        ),
        row=subplot_idx, col=1
    )

    # 添加中位数线（使用Scatter实现带悬停信息的垂直线）
    fig.add_trace(
        go.Scatter(
            x=[median, median],
            y=[0, y_line_max],
            mode='lines',
            name=f'中位数: {median:.2f}ms',
            line=dict(
                color='#FF8C00',  # 深橙色，更明显
                width=2.5,       # 增加线宽
                dash='dot'
            ),
            showlegend=False,
            hovertemplate=f'中位数: {median:.2f} ms<extra></extra>',
            hoverlabel=dict(bgcolor='rgba(255, 140, 0, 0.8)')
        ),
        row=subplot_idx, col=1
    )
```

#### 3.2.5 整体统计信息

```python
# 添加统计信息文本标注（只在最后一个子图添加整体统计信息）
if subplot_idx == len(all_songs):
    # 使用整体统计信息
    overall_mean = statistics.get('mean', 0)
    overall_std = statistics.get('std', 0)
    overall_median = statistics.get('median', 0)
    overall_count = statistics.get('count', 0)

    fig.add_annotation(
        x=0.02, y=0.98,
        xref=f'x{subplot_idx} domain', yref=f'y{subplot_idx} domain',
        text=f"整体统计:<br>均值: {overall_mean:.2f} ms<br>标准差: {overall_std:.2f} ms<br>中位数: {overall_median:.2f} ms<br>数据点数: {overall_count}<br>±1σ: {overall_1sigma:.1f}%<br>±2σ: {overall_2sigma:.1f}%<br>±3σ: {overall_3sigma:.1f}%",
        showarrow=False, align='left',
        bgcolor='rgba(255, 255, 255, 0.8)',
        bordercolor='rgba(0, 0, 0, 0.3)', borderwidth=1,
        font=dict(size=9)
    )
```

#### 3.2.6 布局设置

```python
# 根据子图数量调整图表高度
base_height_per_subplot = 500  # 增加每个子图的高度
total_height = base_height_per_subplot * num_subplots

# 更新整体布局
fig.update_layout(
    title='',  # 不使用主标题，子图标题已包含足够信息
    height=total_height,
    hovermode='x unified',
    template='plotly_white',
    showlegend=False,  # 不使用图注，因为每个子图独立
    margin=dict(l=80, r=60, t=60, b=80)  # 增加上下边距
)

# 更新每个子图的坐标轴
for subplot_idx in range(1, num_subplots + 1):
    fig.update_xaxes(title_text='相对延时 (ms)', row=subplot_idx, col=1)
    fig.update_yaxes(title_text='频数', row=subplot_idx, col=1)
```

---

## 四、核心特性

### 4.1 相对延时概念

**定义**：`相对延时 = 原始延时 - 平均延时`

**目的**：
- 消除算法的整体偏移影响
- 突出延时数据内在的分布特征
- 便于比较不同曲子上的表现一致性

### 4.2 可视化元素

| 元素 | 说明 | 样式 |
|------|------|------|
| 直方图 | 显示频数分布 | 半透明柱状图，汇总图边框更粗 |
| 密度曲线 | KDE平滑曲线 | 实线（单个曲子）/虚线（汇总） |
| 均值线 | 显示数据均值 | 深绿色虚线，线宽2.5px，带悬停信息 |
| 中位数线 | 显示数据中位数 | 深橙色点线，线宽2.5px，带悬停信息 |
| σ区间 | 背景色区域 | 透明度递增的红色背景 |

### 4.3 布局设计

- **子图数量**：`每个曲子 + 每个算法组的汇总`
- **标题格式**：`{算法名} - {文件名}` 或 `{算法名} (汇总)`
- **颜色编码**：相同算法使用相同颜色，不同算法使用不同颜色
- **高度调整**：根据子图数量动态调整总高度

---

## 五、使用场景

1. **算法一致性评估**：检查同种算法在不同曲子上的延时分布是否相似
2. **异常检测**：识别在某些曲子上表现异常的算法
3. **性能对比**：比较不同算法在相同类型曲子上的分布特征
4. **数据质量检查**：发现延时数据中的异常模式或离群点

---

## 六、技术要点

### 6.1 算法识别逻辑

```python
# 同种算法识别条件：
# 1. display_name 相同（用户定义的算法类别）
# 2. algorithm_name 不同（实际文件名不同）
# 3. 至少包含2个及以上的曲子
```

### 6.2 数据处理流程

```python
# 1. 原始数据提取：keyon_offset → ms单位转换
# 2. 平均延时计算：所有匹配点的算术平均值
# 3. 相对延时计算：逐点相减
# 4. 数据分组：单个曲子 vs 算法组汇总
# 5. 统计量计算：均值、标准差、中位数、σ百分比
```

### 6.3 性能优化

- **直方图分箱**：50个bin，平衡细节和性能
- **KDE采样**：200个点，平滑曲线绘制
- **内存管理**：numpy数组处理大数据集
- **颜色复用**：相同算法共享颜色，减少视觉混乱

### 6.4 用户体验优化

- **参考线绘制**：使用Scatter代替vline，实现悬停信息展示
- **颜色深度**：均值线使用深绿色(#2E8B57)，中位数线使用深橙色(#FF8C00)
- **线条粗细**：参考线线宽从1.5px增加到2.5px，提升视觉清晰度
- **悬停交互**：添加hovertemplate显示精确数值和半透明背景标签
- **动态高度**：参考线根据数据范围自动调整高度，确保完整显示
