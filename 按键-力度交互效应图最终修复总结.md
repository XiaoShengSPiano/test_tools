# 按键-力度交互效应图 - 最终修复总结

## 修复内容

### 1. 纵轴修改：锤速差值 → 相对延时
- **之前**：纵轴显示锤速差值（播放锤速 - 录制锤速）
- **现在**：纵轴显示相对延时（keyon_offset - mean_offset），单位：ms

### 2. 按键选择模式：单选（互斥）
- **行为**：
  - 点击按键A → 只显示按键A的数据点
  - 再次点击按键A → 取消选择，显示所有按键
  - 点击按键B → 自动切换到按键B（按键A被取消选择）
- **实现**：使用 `clickData` 事件监听图例点击

### 3. 算法选择模式：多选
- **行为**：可以同时选择多个算法进行对比
- **实现**：toggle模式（点击添加/移除）

## 修改的文件

### `backend/delay_analysis.py`

#### 1. `_extract_key_force_delay_data`
```python
# 返回值改为：(key_id, replay_velocity, delay_ms, record_idx, replay_idx)
# 不再返回：velocity_diff, record_velocity, log10_velocity
# 新增：从offset_data提取延时信息
```

#### 2. `analyze_key_force_interaction`
```python
# 使用新的数据结构：
# - replay_velocities_list: 播放锤速
# - delays_list: 延时（不是锤速差值）
# - 移除：velocity_diffs_list, record_velocities_list, log10_velocities_list
```

#### 3. `_generate_interaction_plot_data`
```python
# 计算相对延时：
relative_delays = [delay - mean_delay for delay in delays]

# 返回数据包含：
# - forces: 播放锤速
# - delays: 相对延时
# - absolute_delays: 原始延时
# - mean_delay: 整体平均延时
```

### `backend/plot_generator.py`

#### 1. 纵轴标题
```python
yaxis_title='相对延时 (ms)'  # 之前是 '锤速差值 (播放 - 录制)'
```

#### 2. `_add_single_trace` - customdata格式
```python
# 新格式：[key_id, replay_velocity, relative_delay, absolute_delay, algorithm_name, mean_delay]
# 旧格式：[key_id, replay_velocity, velocity_diff, algorithm_name]
```

#### 3. hover模板
```python
hovertemplate=hover_prefix +
    f'<b>按键 {key_id}</b><br>' +
    '<b>log₁₀(播放锤速)</b>: %{x:.2f}<br>' +
    '<b>播放锤速</b>: %{customdata[1]:.0f}<br>' +
    '<b>相对延时</b>: %{y:.2f}ms<br>' +
    '<b>原始延时</b>: %{customdata[3]:.2f}ms<br>' +
    f'<i>平均延时: {mean_delay:.2f}ms</i><extra></extra>'
```

#### 4. 控制图注（支持clickData）
```python
x=[0], y=[0]  # 在原点放置透明点
opacity=0     # 完全透明
hoverinfo='skip'
```

### `ui/callbacks.py`

#### 1. 回调事件改为 `clickData`
```python
@app.callback(
    [...],
    [Input('key-force-interaction-plot', 'clickData')],  # 之前是 restyleData
    ...
)
```

#### 2. 按键单选逻辑
```python
if key_id in selected_keys and len(selected_keys) == 1:
    # 取消选择
    selected_keys = []
else:
    # 单选（清空其他按键）
    selected_keys = [key_id]
```

#### 3. customdata解析更新
```python
# 索引4：algorithm_name（之前是索引3）
trace_algorithm = str(first_point[4]) if first_point[4] else ''
```

## 数据流程

```
1. matched_pairs + offset_data
   ↓
2. _extract_key_force_delay_data
   → (key_id, replay_velocity, delay_ms, record_idx, replay_idx)
   ↓
3. analyze_key_force_interaction
   → key_ids_list, replay_velocities_list, delays_list
   ↓
4. _generate_interaction_plot_data
   → 计算 relative_delays = delay - mean_delay
   → 按key_id分组
   ↓
5. generate_key_force_interaction_plot
   → 横轴：log₁₀(播放锤速)
   → 纵轴：相对延时
   ↓
6. 用户点击按键图例
   ↓
7. clickData事件 → handle_key_force_interaction_selection
   → selected_keys = [clicked_key_id]  # 单选
   ↓
8. handle_generate_key_force_interaction_plot
   → 更新数据点可见性
   → 只显示selected_keys中的按键
```

## 测试场景

### 场景1：选择单个按键
1. 点击"按键16"图例
2. **预期**：只显示按键16的数据点（相对延时 vs log₁₀锤速）
3. **日志**：`[LEGEND] 单选按键: 16`

### 场景2：切换按键
1. 先点击"按键16"
2. 再点击"按键21"
3. **预期**：按键16的数据点消失，只显示按键21的数据点
4. **日志**：`[LEGEND] 单选按键: 21`

### 场景3：取消选择
1. 点击"按键16"（选中）
2. 再次点击"按键16"
3. **预期**：显示所有按键的数据点
4. **日志**：`[LEGEND] 取消选择按键: 16 (清空选择)`

### 场景4：算法+按键组合
1. 点击"算法A"和"算法B"（多选）
2. 点击"按键16"（单选）
3. **预期**：显示算法A和算法B中按键16的数据点

## 关键改进

1. ✅ **纵轴含义正确**：相对延时，而不是锤速差值
2. ✅ **按键单选**：避免多按键同时选中的混乱
3. ✅ **可靠触发**：clickData事件确保图例点击能被捕获
4. ✅ **数据完整**：保留原始延时和平均延时供参考
5. ✅ **调试友好**：详细的日志输出

## 注意事项

1. **相对延时计算**：相对延时 = 原始延时 - 整体平均延时
2. **y=0参考线**：红色横线表示平均延时位置
3. **hover显示**：同时显示相对延时和原始延时，便于理解
4. **控制图注位置**：在(0,0)放置透明点，不影响可见区域

