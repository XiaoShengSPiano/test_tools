# 按键-力度交互效应图 - 控制修复（最终版）

## 修复的问题

### 1. 横轴显示"100"的问题
**原因**：控制图注的点放在 `(0, 0)` 位置，`log₁₀(0)` 导致显示异常

**解决**：将控制图注的点放在 `(-1000, -1000)`，远离数据范围
- 点的大小：0.1（极小）
- 透明度：0（完全透明）
- 不影响图表的可见范围

### 2. y=0位置的黄色方块
**原因**：控制图注在 `(0, 0)` 位置显示

**解决**：移到 `(-1000, -1000)`，不再出现在可见区域

### 3. 按键选择逻辑
**需求**：点击按键图注 → 显示**所有算法**中该按键的数据点

**实现**：
- 按键选择：单选模式（互斥）
- 算法选择：多选模式
- 点击按键后，显示选中按键在所有选中算法中的数据

## 实现细节

### 控制图注位置
```python
# 算法控制图注
fig.add_trace(go.Scatter(
    x=[-1000],  # 远离数据范围
    y=[-1000],
    mode='markers',
    marker=dict(size=0.1, opacity=0),  # 极小且透明
    customdata=[[algorithm_name, 'algorithm']],  # 标识类型
    ...
))

# 按键控制图注
fig.add_trace(go.Scatter(
    x=[-1000],
    y=[-1000],
    mode='markers',
    marker=dict(size=0.1, opacity=0),
    customdata=[[key_id, 'key']],  # 标识类型
    ...
))
```

### clickData处理逻辑
```python
# 1. 获取点击的点的customdata
point_customdata = point.get('customdata')

# 2. 判断是否是控制图注
if customdata[1] in ['key', 'algorithm']:
    # 是控制图注
    
# 3. 按键控制（单选）
if control_type == 'key':
    if key_id in selected_keys and len(selected_keys) == 1:
        selected_keys = []  # 取消选择
    else:
        selected_keys = [key_id]  # 单选

# 4. 算法控制（多选）
if control_type == 'algorithm':
    if algorithm in selected_algorithms:
        selected_algorithms.remove(algorithm)  # 取消
    else:
        selected_algorithms.append(algorithm)  # 添加
```

### 数据点可见性逻辑
```python
# 如果没有选择任何算法或按键 → 显示所有
if not selected_algorithms and not selected_keys:
    return True

# 算法匹配
algorithm_match = True
if selected_algorithms:
    algorithm_match = trace_algorithm in selected_algorithms

# 按键匹配
key_match = True
if selected_keys:
    key_match = trace_key_id in selected_keys

# 同时满足算法和按键条件
return algorithm_match and key_match
```

## 使用场景

### 场景1：查看单个按键在所有算法中的表现
1. **不选择任何算法**（显示所有算法）
2. **点击"按键16"**
3. **结果**：显示所有算法中按键16的数据点
   - pid算法的按键16：蓝色点
   - smc算法的按键16：橙色点

### 场景2：查看单个按键在特定算法中的表现
1. **点击"pid算法"**（选中）
2. **点击"按键16"**
3. **结果**：只显示pid算法中按键16的数据点

### 场景3：对比多个算法中的单个按键
1. **点击"pid"和"smc"**（选中两个算法）
2. **点击"按键16"**
3. **结果**：显示pid和smc算法中按键16的数据点

### 场景4：切换按键
1. 当前选中"按键16"
2. **点击"按键21"**
3. **结果**：自动切换到按键21（按键16被取消）

### 场景5：取消按键选择
1. 当前选中"按键16"
2. **再次点击"按键16"**
3. **结果**：取消选择，显示所有按键

## 图表说明

- **横轴**：log₁₀(播放锤速)
- **纵轴**：相对延时（ms）
- **y=0红线**：平均延时参考线
- **算法图注**：圆形标记，多选模式
- **按键图注**：方形标记，单选模式
- **数据点**：
  - 颜色：按算法区分
  - 位置：(log₁₀锤速, 相对延时)

## 调试日志

点击按键时的日志输出：
```
[LEGEND] ========== 图注点击事件开始 ==========
[LEGEND] 当前状态 - 算法: [], 按键: []
[LEGEND] 点击事件 - curve_number: X, point: {...}
[LEGEND] point customdata: [16, 'key']
[LEGEND] 点击的控制图注: type=key, value=16
[LEGEND] 单选按键: 16
[LEGEND]   → 返回按键: [16]
[VISIBILITY] 开始更新可见性, 选择的按键: [16]
[TRACE] ★ key=16, alg='pid', result=True
[TRACE] ★ key=16, alg='smc', result=True
[VISIBILITY] ✓ 完成: X/Y 可见
```

## 注意事项

1. **控制图注位置**：`(-1000, -1000)` 不会影响图表的自动缩放
2. **点击检测**：通过 `customdata` 的第二个元素判断是控制图注还是数据点
3. **图例显示**：控制图注仍然在图例中正常显示
4. **按键互斥**：每次只能选择一个按键，但可以选择多个算法

